# 数据类型，数学运算，逻辑和函数 {#ch3}



## 数据类型 (Data Types)

R没有标量，它通过各种类型的向量 (vector)来存储数据。常用的数据类型有：

|类型     |含义与说明            |例子                        |
|:--------|:---------------------|:---------------------------|
|numeric  |浮点数向量            |`3`, `0.5`, `sqrt(2)`, `NaN`, `Inf`|
|integer  |整数向量              |`3L`, `100L`                |
|character|字符向量；需被引号包围|`"1"`, `"$"`, `"你好"`      |
|logical  |逻辑向量              |`TRUE`, `FALSE`, `NA`       |
|complex  |复数向量              |`3+5i`, `1i`, `1+0i`        |


|xxx|描述|xxx|
|:-|:-|:-
|factor   |因子，用于标记样本    |                            |

通过`class()`函数，可以查看指定数据的类型。（除此之外，`typeof()`, `mode()`, `storage.mode()`这三个函数的功能与`class()`类似，但有重要区别；为避免造成困惑，此处不展开讨论）。

## 数学运算

### 数的表达

#### 浮点数

除非指定作为整数（见下），在R中所有的数都被存储为双精度浮点数的格式 (double-precision floating-point format)，其`class`为`numeric`。

```{r}
class(3)
```

这会导致一些有趣的现象，比如$(\sqrt{3})^2 \neq 3$：~~（强迫症患者浑身难受）~~

```{r}
sqrt(3)^2-3
```

浮点数的计算比精确数的计算快很多。如果你是第一次接触浮点数，可能会觉得它不可靠，其实不然。在绝大多数情况下，牺牲的这一点点精度并不会影响计算结果（我们的结果所需要的有效数字一般不会超过10位）。

`NaN`（非数）和`Inf`（无限大）也是浮点数！

```{r}
class(NaN)
class(Inf)
```

#### 科学计数法

R可以使用科学计数法(`AeB`$= A \times 10^B$)，比如：

```{r}
3.1e5
```
```{r}
-1.2e-4+1.1e-5
```

#### 整数

整数的class为`integer`。有两种常见的方法创建整数：
1）在数后面加上`L`；

```{r}
class(2)
class(2L)
```

2）创建数列

```{r}
1:10 #公差为1的整数向量生成器，包含最小值和最大值
class(1:10)
seq(5,50,5) #自定义公差，首项，末项和公差可以不为整数
class(seq(5,50,5)) #因此产生的是一个浮点数向量
seq(5L,50L,5L) #可以强制生成整数
class(seq(5L,50L,5L)) #完美
```



整数最常见的用处是indexing（索引）。

##### 整数变成浮点数的情况

这一小段讲的比较细，初学者可以直接跳到下一节（\@ref(arithmetic)）。

整数与整数之前的加，减，乘，求整数商，和求余数计算会得到整数，其他的运算都会得到浮点数，（阶乘(`factorial`)也是，即便现实中不管怎么阶乘都不可能得到非整数）：
```{r include=FALSE}
x <- list(2L+1L, 2L-1L, 2L*3L, 17L%/%3L, 17L%%3L, 1000L/1L, 3L^4L, sqrt(4L), log(exp(5L)),factorial(5L),sin(0L))
for (num in x){
  print(num)
  print(class(num))
}

y <- c(8L/2L, 2L^3L)
```

```{r}
class(2L+1L)
class(2L-1L)
class(2L*3L)
class(17L%/%3L)
class(17L%%3L)
```

```{r}
class(1000L/1L)
class(3L^4L)
class(sqrt(4L))
class(log(exp(5L)))
class(factorial(5L))
```

整数与浮点数之间的运算，显然，全部都会产生浮点数结果，无需举例。

另外一个需要注意的地方是，取整函数\@ref(quzheng)并不会产生整数。如果需要的话，要用`as.integer()`函数。

### 运算 {#arithmetic}

#### 二元运算符号

R中的binary operators（二元运算符）有：

|  符号     |     描述    |
|:---------:|:-----------:|
|   `+`     | 加          |
| `-`       | 减          |
| `*`       | 乘          |
| `/`       | 除以        |
| `^`或`**` | 乘幂        |
|`%/%`      |求整数商，比如`7%%3`$=2$|
|`%%`       |求余数，比如`7%%3`$=1$|

其中求余/求整数商最常见的两个用法是判定一个数的奇偶性，和时间，角度等单位的转换。（后面再详细介绍）。

#### $e^x$和$\log_x{y}$

`exp(x)`便是运算$e^x$。如果想要$e=2.71828...$这个数：

```{r}
exp(1)
```

`log(x, base=y)`便是运算$\log_y{x}$，可以简写成`log(x,y)`（简写需要注意前后顺序，下面讲函数的时候会解释）。

默认底数为$e$：

```{r}
log(exp(5))
```

有以10和2为底的快捷函数, `log10()`和`log2()`

```{r}
log10(1000)
log2(128)
```

#### 近似数（取整，取小数位，取有效数字）{#quzheng}

注意，取整函数给出的的结果不是整数！

```{r}
class(ceiling(7.4))
```


#### R中自带的数学函数集合

|函数          |描述          |
|:---------------|:-------------|
|`exp(x)`        |$e^x$         |
|`log(x,y)`      |$\log_yx$     |
|`log(x)`        |$\ln(x)$     |
|`sqrt(x)`       |$\sqrt{x}$    |
|`factorial(x)`  |$x!=x\times(x-1)\times(x-2)\ldots\times2\times1$|
|`choose(n,k)`   |$\binom{n}{k}=\frac{n!}{k!(n-k)!}$（二项式系数）|
|`gamma(z)`      |$\Gamma(z)=\int_0^\infty x^{z-1}e^{-x}dx$（[伽马函数](https://en.wikipedia.org/wiki/Gamma_function)）|
|`lgamma(z)`     |$\ln(\Gamma(z))$|
|`floor(x)`, `ceiling(x)`, `trunc(x)`, |取整；见上一小节。|
|`round(x, digits = n)`|四舍五入，保留n个小数位，n默认为0|
|`signif(x,digits = n)`|四舍五入，保留n个有效数字，n默认为6）|
|`sin(x)`, `cos(x)`, `tan(x)`|三角函数|
|`asin(x)`, `acos(x)`, `atan(x)`|反三角函数|
|`sinh(x)`, `cosh(x)`, `tanh(x)`|双曲函数|
|`abs(x)`|$|x|$（取绝对值）|

## 变量

## 逻辑

### TRUE和FALSE

### Logical Operators（逻辑运算符）

R中的logical operators 有：

|符号|描述|
|:--:|:----:|
|`==`  |equal to（等于）|
|`!=`  |equal to（不等于）|
|`<`|less than（小于）|
|`>`|more than（大于）|
|`<=`|less than or equal to（小于等于）|
|`>=`|more than or equal to（大于等于）|
|`&`|AND（和）|
|`|`|OR（或）|
|`!`|反义符号（见下）|

## 以下是不重要的一些内容

### Console和R script编辑器的一些特性

Console 中每个命令开头的`>`叫做prompt（我不知道它的中文名诶），当它出现在你所编辑的那一行的开头时，按下回车的时候那行的命令才会被执行。有时候它会消失，这时候按`esc`可以将其恢复。

prompt消失的主要原因是你的代码没有写完，比如括号不完整：

```{}
> 2+(3+4
```

这时你按回车，它会显示：

```{}
> 2+(3+4
+
```

`+`号是在提示代码没写完整。这时你把括号补上再按回车：

```{}
> 2+(3+4
+ )
```

```{}
[1] 9
```

便可以完成计算。

这意味着我们可以把一条很长的命令分成很多行。比如我们可以写这样的代码（在R script编辑器中！）

```{r eval=FALSE}
if(1 + 1 == 2 & 1 + 2 == 5){
  print(2)
} else{
  print(3)
}
```

然后`Ctrl`+`Enter`执行。


```{}
<function>(<argument> = <value>)
```

### 赋值(assignment): 使用`<-`，而不是`=`

与很多其他的计算机语言不同，`<-`是R中的赋值符号：

```{r}
x <- 2
```

## 函数

不像很多其他语言的函数有`value.func()`和`func value`等格式，R中所有函数的通用格式是这样的：

```{}
function(argument1=value1, argument2=value2, ...)
```

比如

```{r}
x1 <- c(5.1,5.2,4.5,5.3,4.3,5.5,5.7)
t.test(x=x1, mu = 4.5)
```

### 关于"..."

有时候，你想写的函数可能有数量不确定的arguments

If a function has ‘...’ as a formal argument then any actual arguments that do not match a formal argument are matched with ‘...’.

## 简易的统计学计算

### t分布

下面介绍的这几种方法是以这个t分布函数图为基础的：

```{r include=FALSE}
library(tidyverse)
```

```{r echo=FALSE}
t.values <- seq(-4.5,4.5,.1)

t.probability <- dt(t.values,df=6)

all <- tibble(val=t.values,prob=t.probability)

cut <- tibble(val=t.values[1:75],prob=t.probability[1:75])

ggplot()+
  geom_line(data=all, aes(x=val,y=prob))+
  geom_area(data=cut,aes(x=val,y=prob))+
  theme_light()+
  labs(x="t",y="probability density")+
  geom_vline(xintercept = 2.9, linetype="dashed", color='grey')+
  geom_text(aes(x=3,y=0.1, label="t*"))+
  scale_y_continuous(expand = c(0,0)) + scale_x_continuous(expand = c(0,0))
```

阴影区域为$P$，虚线对应的$t$为$t^*$. `qt()`可以把$P$转化成$t^*$,`pt()`则相反。

举个例子就明白了。假设你需要算一个confidence interval（置信区间），confidence level（置信等级）为$95\%$，即$\alpha=0.05$，degrees of freedom(自由度)为$12$，那么怎么算$t^*$呢？

```{r}
qt(0.975, df = 12)
```

对，就是这么简单。（为什么是$0.975$？因为你要把$0.05$分到左右两边，就等同于t分布的$t=0.095$）

再举一个例子，你在做t检验，双尾的，算出来$t=1.345$，自由度是$15$，那么$p$值怎么算呢？

```{r}
p <- (1-(pt(2.2, df = 15)))*2
p
```

其中`pt(2.2, df = 15)`算出阴影面积，1减去它再乘以二就是对应的双尾t检验的$p$值。

### z分布

没有z分布专门的函数。可以直接用t分布代替，把`df`调到很大（比如`999999`）就行了。比如我们试一下$95\%$置信区间所对应的$z$：
```{r}
qt(0.975,9999999)
```
（果然是$1.96$）

### t检验

t test分为以下几种：

- One sample t test
- Two sample...
  - paired t test
  - Unequal variance t test
  - Equal variance t test
  
在R中做t检验，很简单，以上这些t检验，都是用`t.test` 这个函数去完成。

以one sample为例：

```{r}
x <- c(2.23,2.24,2.34,2.31,2.35,2.27,2.29,2.26,2.25,2.21,2.29,2.34,2.32)
t.test(x, mu = 2.31)
```

可以看到$p=0.06766$。

R的默认是双尾检验，你也可以设置成单尾的：

```{r}
x <- c(2.23,2.24,2.34,2.31,2.35,2.27,2.29,2.26,2.25,2.21,2.29,2.34,2.32)

t.test(x, mu = 2.31, alternative = "less")
```

$p$值一下就减了一半。

Two-sample:

```{r}
x <- c(2.23,2.24,2.34,2.31,2.35,2.27,2.29,2.26,2.25,2.21,2.29,2.34,2.32)
y <- c(2.27,2.29,2.37,2.38,2.39,2.25,2.39,2.16,2.55,2.81,2.19,2.44,2.22)

t.test(x, y)
```

r的默认是non-paired, unequal variance，你可以通过增加`paired = TRUE`，`var.equal = TRUE`这两个参数来改变它。

```{r}
t.test(x, y, paired = TRUE)
```

### $\chi^2$ 检验

$\chi^2$有两种，good
