[
["index.html", "《R与tidyverse——数据分析入门》练习题答案 1 R和RStudio介绍和安装教程", " 《R与tidyverse——数据分析入门》练习题答案 石天熠 2019-07-31 1 R和RStudio介绍和安装教程 "],
["r.html", "2 R中的数据，逻辑，和函数 2.1 基础 2.2 进阶 2.3 挑战", " 2 R中的数据，逻辑，和函数 2.1 基础 2.1.1 向量取子集和逻辑运算 2.1.1.1 问题 x &lt;- c(3, 4, 6, 1, NA, 8, 2, 5, NA, 9, 7) x[-c(1, 3)], x[(length(x)-3):length(x)], x[x &lt; 5], x[!(x &lt; 5)]的计算结果分别是？如何得到（不包含NA的）所有小于5的值的向量？ 2.1.1.2 答案 加上“且不为NA”的条件即可： x[x &lt; 5 &amp; !is.na(x)] #&gt; [1] 3 4 1 2 2.1.2 转换年份到世纪 2.1.2.1 问题 写一个名为as.century()的函数，把存储着年份的向量，比如years &lt;- c(2014, 1990, 1398, 1290, 1880, 2001)，转换成对应的世纪（注意，19XX年是20世纪），像这样： as.century(c(2014, 1990, 1398, 1290, 1880, 2001)) #&gt; [1] 21 20 14 13 19 21 2.1.2.2 答案 as.century &lt;- function(x) x%/%100 + 1 2.1.3 分割时间为时和分 2.1.3.1 问题 写名为hour(), minute()的函数，使得： times &lt;- c(0512, 0719, 2358, 0501) hour(times) #&gt; [1] 5 7 23 5 minute(times) #&gt; [1] 12 19 58 1 2.1.3.2 答案 分别为求除以100的整数商和余数。 hour &lt;- function(x) x%/%100 minute &lt;- function(x) x%%100 2.1.4 转换年份到世纪 2.1.4.1 问题 写一个名为as.century()的函数，把存储着年份的向量，比如years &lt;- c(2014, 1990, 1398, 1290, 1880, 2001)，转换成对应的世纪（注意，19XX年是20世纪），像这样： years_1 &lt;- c(2014, 1990, 1398, 1290, 1880, 2000) as.century(years_1) #&gt; [1] 21 20 14 13 19 21 2.1.4.2 答案 as.century &lt;- function(years) { centuries &lt;- floor(years/100+1) return(centuries) } 2.1.5 斐波那契数列 斐波那契数列是指\\(F = [1, 1, 2, 3, 5, 8, ...]\\)1，其中： \\(F_1 = 1\\)，\\(F_2 = 1\\) 从\\(F_3\\)开始，\\(F_i = F_{i-2} + F_{i-1}\\) 2.1.5.1 问题 创建一个函数名为fibon()的函数，使得fibon(i)： 当\\(i\\in \\mathbb{Z}^+\\)时，返回向量\\([F_1, F_2, \\ldots, F_i]\\) 当\\(i\\notin \\mathbb{Z}^+\\)时，返回&quot;请输入一个正整数作为`fibon()`的参数。&quot;2 提示： 虽然在R中整数用1L, 2L等表示，用户在被指示“输入整数”的时候很有可能输入的是2而不是2L. 2是否等于2L?如果是，如何利用它检测输入的是否是整数？（2和2L都要被判定为“是整数”） 斐波那契数列前两位是定义，从第三位开始才是计算得出的。 使用例： fibon(10); fibon(-5) #&gt; [1] 1 1 2 3 5 8 13 21 34 55 #&gt; [1] &quot;请输入一个正整数。&quot; 2.1.5.2 答案 首先，因为\\(F_1 = 1\\)，\\(F_2 = 1\\)是定义，所以在函数中创建一个向量，名为F, 存储前两项： fibon &lt;- function(){ F &lt;- c(1, 1) } 从\\(F_3\\)开始，\\(F_i = F_{i-2} + F_{i-1}\\)，翻译成R代码就是： F[i] &lt;- F[i-2] + F[i-1] 把它放进while循环里： fibon &lt;- function(len = 10){ F &lt;- c(1, 1) i = 3 ## 从3开始 while (i &lt;= len) { ## 到指定的数值结束 F[i] &lt;- F[i-2] + F[i-1] ## 每次计算并加入第i个元素 } } 最后加入正整数的判别，然后整合一下，完成： fibon &lt;- function (len = 10) { if (len == as.integer(len) &amp; len &gt; 0) { # F &lt;- c(1, 1) ## 前两项需要定义 i &lt;- 3 ## 从第三项开始计算 while (i &lt;= len) { F[i] &lt;- F[i-2] + F[i-1] i &lt;- i+1 ## R中不可以使用`i += 1`或者`i++` } return(F[1:len]) } else { return(&quot;请输入一个正整数。&quot;) } } 2.2 进阶 2.2.1 函数的使用 2.2.1.1 问题 seq(0, 20, 5), seq(by = 5, 0, 20, 和seq(by = 5, 0, y = 30, 20)的结果分别是什么？ 2.2.1.2 答案 有命名的实际参数优先，未命名的实际参数按照形式参数定义时的顺序。若有命名实参的名字在形参中无匹配，将被放进...这个大箩筐。 形式参数定义时的顺序，可以通过帮助文档（?seq）获知。它是from, to, by, length.out, along.with, .... seq(0, 20, 5)的三个实参都未命名。因此按照形参的顺序，即seq(from = 0, to = 20, by = 5). seq(by = 5, 0, 20有一个命名实参（by = 5），剩余未命名的0, 20还是按顺序排，因此还是seq(from = 0, to = 20, by = 5). seq(by = 5, 0, y = 30, 20)多出了一个y，它被放进...，还是剩余未命名的0, 20，因此仍然是seq(from = 0, to = 20, by = 5). 2.2.2 创建一个有序数列 分别用sapply(), rep(), 和rapply()创建这样一个数列（向量）：\\[x = \\left(1\\times1\\times1, 1\\times1\\times2\\ldots, 40\\times50\\times59, 40\\times50\\times60\\right)\\] 2.2.2.1 基于sapply() 先创建m, N相乘的矩阵，再创建l乘这个矩阵形成的三维数组。最后化简为向量。 MN &lt;- sapply(M, function(m){m*N}) LMN &lt;- sapply(L, function(l){l*MN}) result &lt;- as.vector(LMN) 或 MN &lt;- sapply(M, &quot;*&quot;, N) LMN &lt;- sapply(L, &quot;*&quot;, MN) result &lt;- as.vector(LMN) 2.2.2.2 基于rep() MN &lt;- rep(N, length(M)) * rep(M, each = length(N)) result &lt;- rep(MN, length(L)) * rep(L, each = length(MN)) 或（基于recycling rule, 回收规则） MN &lt;- N * rep(M, each = length(N)) result &lt;- MN * rep(L, each = length(MN)) 2.2.2.3 基于rapply() MN &lt;- rapply(as.list(M), &quot;*&quot;, N) result &lt;- rapply(as.list(L), &quot;*&quot;, MN) 2.2.3 质数表 创建一个pr()函数，使pr(i)得到\\((2, 3, 5, 7, 11, ... n)\\), 其中i为大于或等于3的整数，\\(n\\)为小于i的最大质数。 pr(100) #&gt; [1] 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 #&gt; [24] 89 97 你能想到几种方法？哪一种更快？为什么？ 2.2.3.1 使用for循环 pr.for &lt;- function(i){ pnums &lt;- 2L for (num in 3:i) { isPrime &lt;- TRUE for (pnum in pnums) { if (pnum &gt; sqrt(num)) { break } else if (num %% pnum == 0) { isPrime &lt;- FALSE break } } if (isPrime) { pnums &lt;- c(pnums, num) } } return(pnums) } 2.2.3.2 使用while循环 pr.while &lt;- function(i){ pnums &lt;- 2L for (num in 3:i) { isPrime &lt;- TRUE j = 1 while (pnums[j] &lt;= sqrt(num)){ if (num %% pnums[j] == 0) { isPrime &lt;- FALSE break } j = j+1 } if (isPrime) { pnums &lt;- c(pnums, num) ## common mistake } } return(pnums) } 2.2.3.3 使用any pr.any &lt;- function(i){ pnums &lt;- 2L for (num in 3:i) { isPrime &lt;- !any(num %% pnums[pnums &lt;= sqrt(num)] == 0) if (isPrime) { pnums &lt;- c(pnums, num) } } return(pnums) } 2.2.3.4 使用all pr.all &lt;- function(i){ pnums &lt;- 2L for (num in 3:i) { isPrime &lt;- all(num %% pnums[pnums &lt;= sqrt(num)] != 0) if (isPrime) { pnums &lt;- c(pnums, num) } } return(pnums) } 2.2.3.5 使用`%in% pr.in &lt;- function(i){ pnums &lt;- 2L for (num in 3:i) { isPrime &lt;- TRUE test &lt;- pnums[pnums&lt;=floor(sqrt(num))] isPrime &lt;- !(0 %in% (num %% test)) if (isPrime) { pnums &lt;- c(pnums, num) } } return(pnums) } 2.2.3.6 使用lapply() pr.lapply &lt;- function(i){ pnums &lt;- 2 lapply(3:i, function(x){ test &lt;- pnums[pnums &lt;= floor(sqrt(x))] if (all(x%%test != 0)) pnums &lt;&lt;- c(pnums, x) }) return(pnums) } 2.2.3.7 使用purrr中的map() library(tidyverse) #&gt; ── Attaching packages ──────── #&gt; ✔ ggplot2 3.2.0 ✔ purrr 0.3.2 #&gt; ✔ tibble 2.1.3 ✔ dplyr 0.8.3 #&gt; ✔ tidyr 0.8.3 ✔ stringr 1.4.0 #&gt; ✔ readr 1.3.1 ✔ forcats 0.4.0 #&gt; ── Conflicts ───────────────── #&gt; ✖ dplyr::filter() masks stats::filter() #&gt; ✖ dplyr::lag() masks stats::lag() pr.map &lt;- function(i){ pnums &lt;- 2L map(3:i, ~{ test &lt;- pnums[pnums&lt;=floor(sqrt(.))] if (all(.%%test != 0)) pnums &lt;&lt;- c(pnums, .) }) return(pnums) } pr.map1 &lt;- function(i){ pnums &lt;- 2L map(3:i, ~{ test &lt;- pnums[pnums&lt;=floor(sqrt(.))] if (!(0 %in% (.%%test))) pnums &lt;&lt;- c(pnums, .) }) return(pnums) } pr.map2 &lt;- function(i){ pnums &lt;- 2 map(3:i, ~{ test &lt;- pnums[pnums&lt;=floor(sqrt(.))] if (is.na(match(0, .%%test))) pnums &lt;&lt;- c(pnums, .) }) return(pnums) } 2.2.3.8 整合 pr.funcs.names &lt;- c(&#39;pr.for&#39;, &#39;pr.while&#39;, &#39;pr.any&#39;, &#39;pr.all&#39;, &#39;pr.in&#39;, &#39;pr.lapply&#39;, &#39;pr.map&#39;, &#39;pr.map1&#39;, &#39;pr.map2&#39;) pr.funcs &lt;- lapply(pr.funcs.names, match.fun) names(pr.funcs) &lt;- pr.funcs.names 2.2.3.9 小检验 t(sapply(pr.funcs, function(x) x(100))) #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] #&gt; pr.for 2 3 5 7 11 13 17 19 23 29 31 37 #&gt; pr.while 2 3 5 7 11 13 17 19 23 29 31 37 #&gt; pr.any 2 3 5 7 11 13 17 19 23 29 31 37 #&gt; pr.all 2 3 5 7 11 13 17 19 23 29 31 37 #&gt; pr.in 2 3 5 7 11 13 17 19 23 29 31 37 #&gt; pr.lapply 2 3 5 7 11 13 17 19 23 29 31 37 #&gt; pr.map 2 3 5 7 11 13 17 19 23 29 31 37 #&gt; pr.map1 2 3 5 7 11 13 17 19 23 29 31 37 #&gt; pr.map2 2 3 5 7 11 13 17 19 23 29 31 37 #&gt; [,13] [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] #&gt; pr.for 41 43 47 53 59 61 67 71 73 79 #&gt; pr.while 41 43 47 53 59 61 67 71 73 79 #&gt; pr.any 41 43 47 53 59 61 67 71 73 79 #&gt; pr.all 41 43 47 53 59 61 67 71 73 79 #&gt; pr.in 41 43 47 53 59 61 67 71 73 79 #&gt; pr.lapply 41 43 47 53 59 61 67 71 73 79 #&gt; pr.map 41 43 47 53 59 61 67 71 73 79 #&gt; pr.map1 41 43 47 53 59 61 67 71 73 79 #&gt; pr.map2 41 43 47 53 59 61 67 71 73 79 #&gt; [,23] [,24] [,25] #&gt; pr.for 83 89 97 #&gt; pr.while 83 89 97 #&gt; pr.any 83 89 97 #&gt; pr.all 83 89 97 #&gt; pr.in 83 89 97 #&gt; pr.lapply 83 89 97 #&gt; pr.map 83 89 97 #&gt; pr.map1 83 89 97 #&gt; pr.map2 83 89 97 2.2.3.10 小测速 n1 &lt;- 100000 map(pr.funcs, ~ .(n1)) 2.2.3.11 速度绘图 我们可以给各函数寻找不同数量的质数的速度绘图： lims &lt;- seq(10000,100000,5000) timeData &lt;- tibble(func = character(0), lim = integer(0), time = double(0)) for(lim in lims) { for(pr in pr.funcs.names){ time &lt;- system.time(match.fun(pr)(lim))[3] timeData &lt;- add_row(timeData, func = pr, lim = lim, time = time) } } 执行上面的代码会花很多时间，因此不妨把这宝贵的数据记录下来，方便日后使用（可以跳过这一步）： readr::write_csv(timeData, &quot;src/prime_list_timeData.csv&quot;) timeData &lt;- read_csv(&quot;src/prime_list_timeData.csv&quot;) 以下是绘图代码，前面两个步骤是为了看图例的时候更方便。最后一个步骤是保存png，可以跳过。 timeData1 &lt;- mutate(timeData, func = fct_reorder(func, time, .fun = function(x) -max(x))) types &lt;- c(rep(&quot;dotted&quot;, 4), rep(&quot;dashed&quot;, 3), rep(&quot;solid&quot;, 2)) ggplot(data = timeData1, mapping = aes(x=lim, y = time, color = func))+ geom_point()+ geom_smooth(se=FALSE, method = &#39;loess&#39;, formula = &#39;y ~ x&#39;, size = 0.5, aes(linetype = func))+ theme_light()+ scale_linetype_manual(values = types) ggsave(&quot;prime_funcs.png&quot;, height = 5, width = 12, dpi = 300) 可以看到，用实线绘制的for和while循环最快，虚线代表的%in%, all, any其次，而点线代表的apply()族函数最慢。 寻找质数本质上是一个迭代计算，无法用向量化的方法去完成，强行使用apply()族函数反而会加重负担。 2.2.4 判断是否是质数 写一个函数，判断一个数是否是质数。 is.prime &lt;- function(n) n == 2L || all(n %% 2L:ceiling(sqrt(n)) != 0) 2.3 挑战 2.3.1 伪·OOP 2.3.1.1 问题 使用且仅使用function(), c(), list(), paste(), print()函数，&lt;-, $, ==符号，和if，实现这样的效果： Pigeon(), Turtle(), Cat()分别创建一只鸽子， 一只乌龟和一只猫（即产生一个list，各自的元素展示如下）： Guoguo &lt;- Pigeon(&quot;Guoguo&quot;) Felix &lt;- Cat(&quot;Felix&quot;, &quot;TRUE&quot;) Kazuya &lt;- Turtle(&quot;Kazuya&quot;) str(Guoguo) #&gt; List of 5 #&gt; $ name : chr &quot;Guoguo&quot; #&gt; $ common_name : chr &quot;pigeon&quot; #&gt; $ binomial_name: chr &quot;Columba livia&quot; #&gt; $ speak : chr &quot;coo&quot; #&gt; $ greet :function (time = &quot;not_specified&quot;) #&gt; ..- attr(*, &quot;srcref&quot;)= &#39;srcref&#39; int [1:8] 6 12 12 3 12 3 6 12 #&gt; .. ..- attr(*, &quot;srcfile&quot;)=Classes &#39;srcfilecopy&#39;, &#39;srcfile&#39; &lt;environment: 0x7ff056149608&gt; str(Kazuya) #&gt; List of 5 #&gt; $ name : chr &quot;Kazuya&quot; #&gt; $ common_name : chr &quot;turtle&quot; #&gt; $ binomial_name: chr &quot;Trachemys scripta elegans&quot; #&gt; $ speak : logi NA #&gt; $ greet :function (time = &quot;not_specified&quot;) #&gt; ..- attr(*, &quot;srcref&quot;)= &#39;srcref&#39; int [1:8] 6 12 12 3 12 3 6 12 #&gt; .. ..- attr(*, &quot;srcfile&quot;)=Classes &#39;srcfilecopy&#39;, &#39;srcfile&#39; &lt;environment: 0x7ff056149608&gt; str(Felix) #&gt; List of 6 #&gt; $ name : chr &quot;Felix&quot; #&gt; $ common_name : chr &quot;cat&quot; #&gt; $ binomial_name: chr &quot;Felis catus&quot; #&gt; $ speak : chr &quot;meow&quot; #&gt; $ greet :function (time = &quot;not_specified&quot;) #&gt; ..- attr(*, &quot;srcref&quot;)= &#39;srcref&#39; int [1:8] 6 12 12 3 12 3 6 12 #&gt; .. ..- attr(*, &quot;srcfile&quot;)=Classes &#39;srcfilecopy&#39;, &#39;srcfile&#39; &lt;environment: 0x7ff056149608&gt; #&gt; $ sterilized : chr &quot;TRUE&quot; 注意，鸽子，乌龟和猫都有名字 (name)，通称 (common_name)，学名 (binomial_name)，和打招呼函数 (greet())；此外，乌龟没有叫声speak()，猫额外地有绝育sterilized信息。可以这样查看信息和使用打招呼函数： Felix$binomial_name #&gt; [1] &quot;Felis catus&quot; Kazuya$greet(&quot;afternoon&quot;) #&gt; [1] &quot;Good afternoon, I&#39;m a turtle and my name is Kazuya&quot; 其中greet()的参数如果是morning, afternoon或evening，则返回&quot;Good &lt;时间段&gt; ...&quot;，否则返回&quot;Hi ...&quot;. 此外，另写两个仅对这些宠物使用的函数binomial_name()和greet()，使之能够这样使用： binomial_name(Kazuya) #&gt; [1] &quot;Trachemys scripta elegans&quot; greet(Guoguo) #&gt; [1] &quot;Hi, I&#39;m a pigeon and my name is Guoguo&quot; 你可能需要的额外信息： 鸽子，乌龟和猫的学名分别为Columba livia, Trachemys scripta elegans, Felis catus. paste()函数把多个字符串拼接成一个，其中参数sep指定连接符号，默认为空格： x &lt;- &quot;world&quot; paste(&quot;Hello&quot;, x, &quot;Bye&quot;, x, sep = &quot;---&quot;) #&gt; [1] &quot;Hello---world---Bye---world&quot; 2.3.1.2 答案 首先，把Cat()函数做出来，这个应该不难看懂： Cat &lt;- function(name){ name = name binomial_name &lt;- &quot;Felis catus&quot; speak &lt;- &quot;Meow&quot; greet &lt;- function(time = &quot;not_specified&quot;){ intro &lt;- paste(&quot;my name is&quot;, name) if(time == &quot;morning&quot;) print(paste(&quot;Good morning,&quot;, intro)) if(time == &quot;afternoon&quot;) print(paste(&quot;Good afternoon,&quot;, intro)) if(time == &quot;evening&quot;) print(paste(&quot;Good evening,&quot;, intro)) if(time == &quot;not_specified&quot;) print(paste(&quot;Hi,&quot;, intro)) } list(name = name, binomial_name = binomial_name, speak = speak, greet = greet) } 你可以对Turtle()和Pigeon()做同样的事情，但是这样会产生很多重复的代码。每当有重复的代码发生时，作为一个正经的编程语言，一定有方法去消除重复。这三类动物都是宠物，因此我们可以把共同的代码写进一个Pet()函数中，再定义不同种类的宠物。这是OOP的inheritance和polymorphism的实现： Pet &lt;- function(name = NA, common_name = NA, binomial_name = NA, speak = NA){ name &lt;- name common_name &lt;- common_name binomial_name &lt;- binomial_name speak &lt;- speak greet &lt;- function(time = &quot;not_specified&quot;){ intro &lt;- paste(&quot;I&#39;m a&quot;, common_name, &quot;and my name is&quot;, name) if(time == &quot;morning&quot;) print(paste(&quot;Good morning,&quot;, intro)) if(time == &quot;afternoon&quot;) print(paste(&quot;Good afternoon,&quot;, intro)) if(time == &quot;evening&quot;) print(paste(&quot;Good evening,&quot;, intro)) if(time == &quot;not_specified&quot;) print(paste(&quot;Hi,&quot;, intro)) } list(name = name, common_name = common_name, binomial_name = binomial_name, speak = speak, greet = greet) } Pigeon &lt;- function(name = NA){ PetAaM &lt;- Pet(name, &quot;pigeon&quot;, &quot;Columba livia&quot;, &quot;coo&quot;) } Turtle &lt;- function(name = NA){ Pet(name, &quot;turtle&quot;, &quot;Trachemys scripta elegans&quot;) ## 实现inheritance ## 龟没有叫声 } Cat &lt;- function(name = NA, sterilized = NA){ sterilized &lt;- sterilized ## 猫可能绝育 ## 新增attribute，实现了广义的polymorphism PetAaM &lt;- Pet(name, &quot;cat&quot;, &quot;Felis catus&quot;, &quot;meow&quot;) CatOnlyAaM &lt;- list(sterilized = sterilized) c(PetAaM, CatOnlyAaM) } ## 实现了Python语境中的polymorphism greet &lt;- function(pet, time = &quot;not_specified&quot;){ pet$greet(time) } binomial_name &lt;- function(pet){ pet$binomial_name } 搞定！没有class，没有self，没有__init__，it just works. 也有\\(F_0=0, F_1=1\\)的说法，但是为了方便我们不用这个定义。↩ 虽然正规的做法是制造一个错误/警告↩ "]
]
